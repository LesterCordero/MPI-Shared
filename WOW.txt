#include <mpi.h> 
#include <iostream>
#include <sstream>
#include <string>
#include <random>
#include <chrono>
#include <cmath>
#include <algorithm>

using namespace std;

void merge(){

}

int main(int argc, char* argv[]) {

	// Inicializacion básica de MPI
	int process_ID;
	int process_num;
	MPI_Init(&argc, &argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &process_ID);
	MPI_Comm_size(MPI_COMM_WORLD, &process_num);

	// Modo de uso obligatorio
	if (argc < (2)) {
		cout << "Error: debe pasar: cantidad de numeros." << endl;
		cin.ignore();
		exit(0);
	}

	// Datos inciales del enunciado
	MPI_Status mpi_status;
	int n = strtol(argv[1], NULL, 10);

	// Notificacion de parámetros iniciales
	if (process_ID == 0) {
		cout << "[MPI] EL ambiente MPI ha iniciado correctamente." << endl;
		cout << "[MPI] Numero de procesos paralelos: " << process_num << endl;
		cout << "[INF] Numero de iteraciones (n): " << n << endl;
		cout << "[INF] Calculando, por favor espere..." << endl;
	}

	// Cambie la semilla
	srand(time(NULL));

	// Cronometro sincronizado
	MPI_Barrier(MPI_COMM_WORLD);
	double local_start = MPI_Wtime();
	int version = 1;
	int repartir = n / process_num;
	int * numeros = new int[n];
	int * numeros_ordenados = new int[n];
	int *sub_numeros = new int[repartir];
	// Si soy el master, genere numeros al azar y luego repartalos a todos los subprocesos
	if (process_ID == 0) {
		cout << "[INF] Lista Random: ";
		for (int i = 0; i < n; ++i) {
			numeros[i] = rand() % n;
			//numeros[i] = n - i;
			cout << numeros[i] << " ";
		}
		cout << endl;
	}

	// Separe en cada subproceso
	MPI_Scatter(numeros, repartir, MPI_INT, sub_numeros, repartir, MPI_INT, 0, MPI_COMM_WORLD);

	// Version 1
	// Cada subproceso hace solamente el sort
	if (version == 1) {
		std::sort(&sub_numeros[0], &sub_numeros[repartir]);
	}
	
	// Junte todo en cada proceso
	MPI_Gather(sub_numeros, repartir, MPI_INT, numeros_ordenados, repartir, MPI_INT, 0, MPI_COMM_WORLD);

	// Ultimo merge en el hilo maestro
	if (process_ID == 0) {

		if (version == 1) {
			int contador = process_num;
			int offset = 1;
			// Pero el merge debe esta en el proceso 0 solamente
			while(contador!=1){
				contador /= 2;
				for (int merges = 0; merges < contador; merges++) {
					int corte = (n*offset) / (process_num / 2);
					int disp = merges*corte;
					cout << "[INF] De " << disp << " hasta " << corte + disp << endl;
					std::inplace_merge(&numeros_ordenados[disp], &numeros_ordenados[(corte/2)+disp], &numeros_ordenados[corte+disp]);

				}
				offset *= 2;
				cout << "[INF] Etapa: " << contador*2 << " a "  << contador << ": ";
				for (int i = 0; i < n; i++) {
					cout << numeros_ordenados[i] << " ";
				}
				cout << endl;
			}
		}

		cout << "[INF] Lista Ordenada: ";
		for (int i = 0; i < n; i++) {
			cout << numeros_ordenados[i] << " ";
		}
		cout << endl;
	}else {

	}

	// Elimine la memoria
	delete[] numeros;
	delete[] numeros_ordenados;
	delete[] sub_numeros;

	// Cronometro final
	double total_elapsed;
	double local_elapsed = MPI_Wtime() - local_start;

	MPI_Reduce(&local_elapsed, &total_elapsed, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);

	// Termina MPI
	if (process_ID == 0) {
		cout << "[INF] Tiempo transcurrido: " << total_elapsed << endl;
		cout << "[MPI] EL ambiente MPI ha terminado correctamente." << endl;

		cin.ignore();
	}

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Finalize();

	return 0;
}